<html>
<script language="javascript" type="text/javascript" src="p5.min.js"></script>
<script language="javascript" type="text/javascript">

var target = {x:250, y:250};
var width = 1000;
var height = 600;
var behavior = null;
var maxTorque = 40.0;
var maxForce = 1000.0;
var maxSpeed = 200.0;
var arrivalDistance = 100;
var THETA = 0;
var VEL = 1;
var THETADOT = 2;
var neighborhood = 200;

class Vehicle
{
    constructor() 
    {
        this.pos = {x:Math.random() * width, y: Math.random() * height};
        this.vel = {x:0, y:0};
        this.veld = {x:0, y:0};
        this.state = [0.,0.,0.];
        this.deriv = [0.,0.,0.];
        this.leader = false;
    }

    draw()
    {
       fill(0,0,255);
       ellipse(this.pos.x, this.pos.y, 25, 25);
       stroke(0,0,0);
       line(this.pos.x, this.pos.y, this.pos.x+this.vel.x, this.pos.y+this.vel.y);
       stroke(0,255,0);
       line(this.pos.x, this.pos.y, this.pos.x+this.veld.x, this.pos.y+this.veld.y);
    }

    sense() 
    {
       var e = document.getElementById("behavior");
       behavior = getBehavior();        

       // compute vd
       var vd = behavior(this);
       this.veld = vd;        
    }

    act() 
    {
       var dt = Number(document.getElementById("dt").value);
       var velKv = Number(document.getElementById("Velkv").value);
       var oriKp = Number(document.getElementById("Orikp").value);
       var oriKv = Number(document.getElementById("Orikv").value);
       var m = Number(document.getElementById("Mass").value);
       var I = Number(document.getElementById("Inertia").value);

       var vd = this.veld;
       var thetad = Math.atan2(vd.y, vd.x);
       var vdspeed = Math.sqrt(vd.x*vd.x + vd.y*vd.y);

       // compute control laws
       // compute smallest angle between thetad and current theta
       var angleDiff = signedMod((thetad - this.state[THETA] + Math.PI), Math.PI * 2.0) - Math.PI;

       var f = m * velKv * (vdspeed - this.state[VEL]);
       var t = I * (oriKp * (angleDiff) - oriKv * (this.state[THETADOT]));

       //f = Math.min(maxForce, Math.max(-maxForce, f));
       t = Math.min(maxTorque, Math.max(-maxTorque, t));

       // compute derivatives and perform Euler step
       this.deriv[THETA] = this.state[THETADOT];
       this.deriv[VEL] = f/m;
       this.deriv[THETADOT] = t/I;

       for (var i = 0; i < this.state.length; i++) {
           this.state[i] += this.deriv[i] * dt;
       }

       // convert local values to global values
       this.vel.x = Math.cos(this.state[THETA]) * this.state[VEL];
       this.vel.y = Math.sin(this.state[THETA]) * this.state[VEL];

       var mag =  Math.sqrt(this.vel.x* this.vel.x +  this.vel.y* this.vel.y);
       if (mag > maxSpeed)
       {
          this.vel.x = (this.vel.x / mag)*maxSpeed;
          this.vel.y = (this.vel.y / mag)*maxSpeed;
       }
       this.pos.x = this.pos.x + this.vel.x * dt;
       this.pos.y = this.pos.y + this.vel.y * dt;

       if (this.pos.x < 0) this.pos.x = width;
       if (this.pos.x > width) this.pos.x = 0;
       if (this.pos.y < 0) this.pos.y = height;
       if (this.pos.y > height) this.pos.y = 0;
    }
}

var agents = [];
var numagents = 5;

function flee(a) {
    var vd = {x: -target.x+a.pos.x, y: -target.y+a.pos.y};
    var mag = Math.sqrt(vd.x*vd.x + vd.y*vd.y);
    var speed = maxSpeed;
    vd.x = vd.x * (speed/mag);
    vd.y = vd.y * (speed/mag);
    return vd;
}

function seek(a) {
    var vd = {x: target.x-a.pos.x, y: target.y-a.pos.y};
    var mag = Math.sqrt(vd.x*vd.x + vd.y*vd.y);
    var speed = maxSpeed;
    vd.x = vd.x * (speed/mag);
    vd.y = vd.y * (speed/mag);
    return vd;
}

function separation(a) {
    var vd = {x: 0, y: 0};
    var minDistance = 100;
    for (var i = 0; i < numagents; i++)
    {
        var px = a.pos.x - agents[i].pos.x;
        var py = a.pos.x - agents[i].pos.x;
        mag = Math.sqrt(px*px + py*py);
        if (mag > 0 && mag < neighborhood)
        {
            vd.x += px / (mag*2);
            vd.y += py / (mag*2);
        }
    }
    vd.x *= 10;
    vd.y *= 10;
    return vd;
}

function alignment(a) {
    var vd = {x: 0, y: 0};
    var aveSpeed = 0;
    var count = 0;
    for (var i = 0; i < numagents; i++)
    {
        var px = a.pos.x - agents[i].pos.x;
        var py = a.pos.x - agents[i].pos.x;
        mag = Math.sqrt(px*px + py*py);
        if (mag > neighborhood) continue;

        var vx = agents[i].vel.x;
        var vy = agents[i].vel.x;
        var mag = Math.sqrt(vx*vx + vy*vy);

        aveSpeed += mag;
        vd.x += vx;
        vd.y += vy;
        count++;
    }
    if (aveSpeed > 0)
    {
        var mag = Math.sqrt(vd.x*vd.x + vd.y*vd.y);
        vd.x = (vd.x / mag) * aveSpeed/count;
        vd.y = (vd.y / mag) * aveSpeed/count;
    }
   
    return vd;
}

function cohesion(a) {
    var vd = {x: 0, y: 0};
    var count = 0;
    for (var i = 0; i < numagents; i++)
    {
        var px = a.pos.x - agents[i].pos.x;
        var py = a.pos.x - agents[i].pos.x;
        mag = Math.sqrt(px*px + py*py);
        if (mag > neighborhood) continue;

        vd.x += agents[i].pos.x;
        vd.y += agents[i].pos.y;
        count++;
    }
    vd.x = vd.x/count - a.pos.x;
    vd.y = vd.y/count - a.pos.y;
    return vd;
}

function flocking(a) {
    var vdArrival = arrival(a);
    var vdCohesion = cohesion(a);
    var vdSeparation = separation(a);
    var vdAlignment = alignment(a);

    var Kar = 10;
    var Kco = 1.5;
    var Kse = 0;
    var Kal = 0.1;
    var vdx = Kco * vdCohesion.x + Kse * vdSeparation.x +  Kal * vdAlignment.x + Kar * vdArrival.x;
    var vdy = Kco * vdCohesion.y + Kse * vdSeparation.y +  Kal * vdAlignment.y + Kar * vdArrival.y;

    var vd = {x: vdx, y: vdy};
    return vd;
}

function leader(a) {
    if (a.leader)
    {
        return arrival(a);
    }

    var vdArrival = {x: agents[0].pos.x-a.pos.x, y: agents[0].pos.y-a.pos.y};
    var mag = Math.sqrt(vdArrival.x*vdArrival.x + vdArrival.y*vdArrival.y);
    var speed = maxSpeed;
    if (mag < arrivalDistance) // slowdown
    {
        var d = (mag/arrivalDistance);
        speed = maxSpeed * d * d * d;
    }
    vdArrival.x = vdArrival.x * (speed/mag);
    vdArrival.y = vdArrival.y * (speed/mag);

    var vdSeparation = separation(a);
    var vdAlignment = alignment(a);
    var vdCohesion = alignment(a);

    var Kar = 2;
    var Kse = 6;
    var Kal = 0;
    var Kco = 0.5;
    var vdx = Kse * vdSeparation.x +  Kar * vdArrival.x + Kal * vdAlignment.x + Kco * vdCohesion.x;
    var vdy = Kse * vdSeparation.y +  Kar * vdArrival.y + Kal * vdAlignment.y + Kco * vdCohesion.y;

    var vd = {x: vdx, y: vdy};
    return vd;
}

function arrival(a) {
    var vd = {x: target.x-a.pos.x, y: target.y-a.pos.y};
    var mag = Math.sqrt(vd.x*vd.x + vd.y*vd.y);
    var speed = maxSpeed;
    if (mag < arrivalDistance) // slowdown
    {
        var a = (mag/arrivalDistance);
        speed = maxSpeed * a * a * a;
    }
    vd.x = vd.x * (speed/mag);
    vd.y = vd.y * (speed/mag);
    return vd;
}

function setup() 
{
    width = 1000.0;
    height = 600.0;
    createCanvas(width, height);
    behavior = arrival;

    for (var i = 0; i < numagents; i++)
    {
       var agent = new Vehicle();
       agents.push(agent);
    }
    agents[0].leader = true;

}

function signedMod(a, n) 
{
   return a - Math.floor(a/n) * n;
}

function getBehavior()
{
   var e = document.getElementById("behavior");
   var strUser = e.options[e.selectedIndex].value;
   if (strUser === "seek") return seek;
   if (strUser === "flee") return flee;
   if (strUser === "path") return followPath;
   if (strUser === "cohesion") return cohesion;
   if (strUser === "alignment") return alignment;
   if (strUser === "separation") return separation;
   if (strUser === "flocking") return flocking;
   if (strUser === "leader") return leader;
   return arrival;
}

function draw() 
{
   background(230);

   if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height && mouseIsPressed)
   {
       target.x = mouseX;
       target.y = mouseY;
   }   


   fill(255,0,0);
   noStroke();
   ellipse(target.x, target.y, 15, 15);

   for (var i = 0; i < numagents; i++)
   {
      agents[i].draw();
   }

   for (var i = 0; i < numagents; i++)
   {
      agents[i].sense();
   }

   for (var i = 0; i < numagents; i++)
   {
      agents[i].act();
   }

   stroke(0,255,0);
   line(2, 2, 2, 250);

   stroke(255,0,0);
   line(2, 2, 250, 2);
}

</script>
<body>
Dt:<input id="dt" type="number" step="0.01" value="0.01"><br>
Ori Kv: <input id="Orikv" type="number" step="0.1" value="20"><br>
Ori Kp: <input id="Orikp" type="number" step="0.1" value="100"><br>
Vel Kv: <input id="Velkv" type="number" step="0.1" value="5"><br>
Mass: <input id="Mass" type="number" step="0.1" value="1"><br>
Inertia: <input id="Inertia" type="number" step="0.1" value="1"><br>
<select id="behavior">
    <option value="arrival">Arrival</option>
    <option value="seek">Seek</option>
    <option value="flee">Flee</option>
    <option value="cohesion">Cohesion</option>
    <option value="alignment">Alignment</option>
    <option value="separation">Separation</option>
    <option value="flocking">Flocking</option>
    <option value="leader">Leader</option>
</select>
<br>
</body>
</html>


